package flightaware

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"os"
	"testing"

	"github.com/rknightion/adsb2loki/pkg/common"
	"github.com/rknightion/adsb2loki/pkg/models"
)

// mockLogger is a mock implementation of the Logger interface for testing
type mockLogger struct {
	entries []common.LogEntry
	err     error
}

func (m *mockLogger) PushLogs(_ context.Context, entries []common.LogEntry) error {
	m.entries = entries
	return m.err
}

func TestFetchAndPushToLoki(t *testing.T) {
	// Create test data using JSON to properly initialize
	testJSON := `{
		"now": 1234567890.123,
		"messages": 100,
		"aircraft": [
			{
				"hex": "ABC123",
				"flight": "TEST123",
				"alt_baro": 35000,
				"lat": 40.7128,
				"lon": -74.0060
			},
			{
				"hex": "DEF456",
				"flight": "TEST456",
				"alt_baro": 25000,
				"lat": 51.5074,
				"lon": -0.1278
			}
		]
	}`

	var testData models.AutoGenerated
	if err := json.Unmarshal([]byte(testJSON), &testData); err != nil {
		t.Fatalf("Failed to create test data: %v", err)
	}

	// Create test server
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(testData); err != nil {
			t.Errorf("Failed to encode test data: %v", err)
		}
	}))
	defer server.Close()

	// Set environment variable
	os.Setenv("AIRCRAFT_JSON_URL", server.URL)

	// Create mock logger
	logger := &mockLogger{}

	// Test successful fetch and push
	ctx := context.Background()
	err := FetchAndPushToLoki(ctx, logger)
	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}

	// Verify entries were pushed
	if len(logger.entries) != 2 {
		t.Errorf("Expected 2 entries, got %d", len(logger.entries))
	}

	// Verify entry content
	for i, entry := range logger.entries {
		if entry.Labels["app"] != "flightaware" {
			t.Errorf("Expected app label to be 'flightaware', got %s", entry.Labels["app"])
		}
		// Verify only 'app' label exists (no high cardinality labels)
		if len(entry.Labels) != 1 {
			t.Errorf("Expected only 1 label (app), got %d labels: %v", len(entry.Labels), entry.Labels)
		}
		// Verify structured metadata contains hex and flight
		if i == 0 && entry.StructuredMetadata["hex"] != "ABC123" {
			t.Errorf("Expected structured metadata hex to be 'ABC123', got %s", entry.StructuredMetadata["hex"])
		}
		if i == 0 && entry.StructuredMetadata["flight"] != "TEST123" {
			t.Errorf("Expected structured metadata flight to be 'TEST123', got %s", entry.StructuredMetadata["flight"])
		}
		if i == 1 && entry.StructuredMetadata["hex"] != "DEF456" {
			t.Errorf("Expected structured metadata hex to be 'DEF456', got %s", entry.StructuredMetadata["hex"])
		}
		if i == 1 && entry.StructuredMetadata["flight"] != "TEST456" {
			t.Errorf("Expected structured metadata flight to be 'TEST456', got %s", entry.StructuredMetadata["flight"])
		}
		// Verify the data is in the log line
		if !contains(entry.Line, "hex") || !contains(entry.Line, "flight") {
			t.Errorf("Expected aircraft data in log line, got: %s", entry.Line)
		}
	}
}

func TestFetchAndPushToLoki_ServerError(t *testing.T) {
	// Create test server that returns an error
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
		w.WriteHeader(http.StatusInternalServerError)
	}))
	defer server.Close()

	// Set environment variable
	os.Setenv("AIRCRAFT_JSON_URL", server.URL)

	// Create mock logger
	logger := &mockLogger{}

	// Test fetch with server error
	ctx := context.Background()
	err := FetchAndPushToLoki(ctx, logger)
	if err == nil {
		t.Error("Expected error for server error, got nil")
	}
}

func TestFetchAndPushToLoki_InvalidJSON(t *testing.T) {
	// Create test server that returns invalid JSON
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		if _, err := w.Write([]byte("invalid json")); err != nil {
			t.Errorf("Failed to write response: %v", err)
		}
	}))
	defer server.Close()

	// Set environment variable
	os.Setenv("AIRCRAFT_JSON_URL", server.URL)

	// Create mock logger
	logger := &mockLogger{}

	// Test fetch with invalid JSON
	ctx := context.Background()
	err := FetchAndPushToLoki(ctx, logger)
	if err == nil {
		t.Error("Expected error for invalid JSON, got nil")
	}
}

func TestFetchAndPushToLoki_ContextCancelled(t *testing.T) {
	// Create test server with delay
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Wait for context to be cancelled
		<-r.Context().Done()
		w.WriteHeader(http.StatusRequestTimeout)
	}))
	defer server.Close()

	// Set environment variable
	os.Setenv("AIRCRAFT_JSON_URL", server.URL)

	// Create mock logger
	logger := &mockLogger{}

	// Create cancelled context
	ctx, cancel := context.WithCancel(context.Background())
	cancel()

	// Test fetch with cancelled context
	err := FetchAndPushToLoki(ctx, logger)
	if err == nil {
		t.Error("Expected error for cancelled context, got nil")
	}
}

// Test with mixed type data (some numeric, some strings)
func TestFetchAndPushToLoki_MixedTypes(t *testing.T) {
	// Create test data with mixed types
	testJSON := `{
		"now": 1234567890.123,
		"messages": 100,
		"aircraft": [
			{
				"hex": "ABC123",
				"flight": "TEST123",
				"alt_baro": 35000,
				"gs": 450.5,
				"lat": 40.7128,
				"lon": -74.0060
			},
			{
				"hex": "DEF456",
				"flight": "GROUND1",
				"alt_baro": "ground",
				"gs": 0,
				"lat": 51.5074,
				"lon": -0.1278
			}
		]
	}`

	// Create test server
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		if _, err := w.Write([]byte(testJSON)); err != nil {
			t.Errorf("Failed to write response: %v", err)
		}
	}))
	defer server.Close()

	// Set environment variable
	os.Setenv("AIRCRAFT_JSON_URL", server.URL)

	// Create mock logger
	logger := &mockLogger{}

	// Test successful fetch and push
	ctx := context.Background()
	err := FetchAndPushToLoki(ctx, logger)
	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}

	// Verify entries were pushed
	if len(logger.entries) != 2 {
		t.Errorf("Expected 2 entries, got %d", len(logger.entries))
	}
}

// Simple contains function for tests
func contains(s, substr string) bool {
	return len(s) >= len(substr) && s[0:len(s)] != "" && s[0:len(substr)] == substr || len(s) > len(substr) && contains(s[1:], substr)
}
