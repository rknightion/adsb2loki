package flightaware

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"os"
	"testing"
	"time"

	"github.com/rknightion/adsb2loki/pkg/common"
	"github.com/rknightion/adsb2loki/pkg/models"
)

// mockLogger implements the common.Logger interface for testing
type mockLogger struct {
	entries []common.LogEntry
	err     error
}

func (m *mockLogger) PushLogs(ctx context.Context, entries []common.LogEntry) error {
	if m.err != nil {
		return m.err
	}
	m.entries = append(m.entries, entries...)
	return nil
}

func TestFetchAndPushToLoki(t *testing.T) {
	// Create test aircraft data
	testData := models.AutoGenerated{
		Now: float64(time.Now().Unix()),
		Aircraft: []struct {
			Hex            string        `json:"hex"`
			Flight         string        `json:"flight,omitempty"`
			AltBaro        int           `json:"alt_baro,omitempty"`
			AltGeom        int           `json:"alt_geom,omitempty"`
			Gs             float64       `json:"gs,omitempty"`
			Ias            int           `json:"ias,omitempty"`
			Tas            int           `json:"tas,omitempty"`
			Mach           float64       `json:"mach,omitempty"`
			Track          float64       `json:"track,omitempty"`
			TrackRate      float64       `json:"track_rate,omitempty"`
			Roll           float64       `json:"roll,omitempty"`
			MagHeading     float64       `json:"mag_heading,omitempty"`
			BaroRate       int           `json:"baro_rate,omitempty"`
			GeomRate       int           `json:"geom_rate,omitempty"`
			Squawk         string        `json:"squawk,omitempty"`
			Emergency      string        `json:"emergency,omitempty"`
			Category       string        `json:"category,omitempty"`
			NavQnh         float64       `json:"nav_qnh,omitempty"`
			NavAltitudeMcp int           `json:"nav_altitude_mcp,omitempty"`
			NavHeading     float64       `json:"nav_heading,omitempty"`
			Lat            float64       `json:"lat,omitempty"`
			Lon            float64       `json:"lon,omitempty"`
			Nic            int           `json:"nic,omitempty"`
			Rc             int           `json:"rc,omitempty"`
			SeenPos        float64       `json:"seen_pos,omitempty"`
			Version        int           `json:"version,omitempty"`
			NicBaro        int           `json:"nic_baro,omitempty"`
			NacP           int           `json:"nac_p,omitempty"`
			NacV           int           `json:"nac_v,omitempty"`
			Sil            int           `json:"sil,omitempty"`
			SilType        string        `json:"sil_type,omitempty"`
			Gva            int           `json:"gva,omitempty"`
			Sda            int           `json:"sda,omitempty"`
			Mlat           []interface{} `json:"mlat"`
			Tisb           []interface{} `json:"tisb"`
			Messages       int           `json:"messages"`
			Seen           float64       `json:"seen"`
			Rssi           float64       `json:"rssi"`
			NavAltitudeFms int           `json:"nav_altitude_fms,omitempty"`
			NavModes       []string      `json:"nav_modes,omitempty"`
		}{
			{
				Hex:     "ABC123",
				Flight:  "TEST123",
				AltBaro: 35000,
				Gs:      450,
				Track:   180,
				Lat:     40.7128,
				Lon:     -74.0060,
			},
			{
				Hex:     "DEF456",
				Flight:  "TEST456",
				AltBaro: 28000,
				Gs:      380,
				Track:   90,
				Lat:     41.8781,
				Lon:     -87.6298,
			},
		},
	}

	// Create test server
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(testData)
	}))
	defer server.Close()

	// Set environment variable
	oldURL := os.Getenv("AIRCRAFT_JSON_URL")
	os.Setenv("AIRCRAFT_JSON_URL", server.URL)
	defer os.Setenv("AIRCRAFT_JSON_URL", oldURL)

	// Create mock logger
	logger := &mockLogger{}

	// Call the function
	ctx := context.Background()
	err := FetchAndPushToLoki(ctx, logger)
	if err != nil {
		t.Fatalf("FetchAndPushToLoki failed: %v", err)
	}

	// Verify results
	if len(logger.entries) != 2 {
		t.Fatalf("Expected 2 log entries, got %d", len(logger.entries))
	}

	// Verify the first entry
	entry := logger.entries[0]
	if entry.Labels["service"] != "flightaware" {
		t.Errorf("Expected service label 'flightaware', got %s", entry.Labels["service"])
	}

	// Verify the timestamp matches the data
	expectedTime := time.Unix(int64(testData.Now), 0)
	if entry.Timestamp != expectedTime {
		t.Errorf("Expected timestamp %v, got %v", expectedTime, entry.Timestamp)
	}

	// Verify the JSON content contains expected hex
	if !contains(entry.Line, `"hex":"ABC123"`) {
		t.Errorf("Expected hex ABC123 in JSON, got %s", entry.Line)
	}
}

func TestFetchAndPushToLokiServerError(t *testing.T) {
	// Create test server that returns an error
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusInternalServerError)
	}))
	defer server.Close()

	// Set environment variable
	oldURL := os.Getenv("AIRCRAFT_JSON_URL")
	os.Setenv("AIRCRAFT_JSON_URL", server.URL)
	defer os.Setenv("AIRCRAFT_JSON_URL", oldURL)

	// Create mock logger
	logger := &mockLogger{}

	// Call the function
	ctx := context.Background()
	err := FetchAndPushToLoki(ctx, logger)
	if err == nil {
		t.Error("Expected error for server error, got nil")
	}
}

func TestFetchAndPushToLokiInvalidJSON(t *testing.T) {
	// Create test server that returns invalid JSON
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("invalid json"))
	}))
	defer server.Close()

	// Set environment variable
	oldURL := os.Getenv("AIRCRAFT_JSON_URL")
	os.Setenv("AIRCRAFT_JSON_URL", server.URL)
	defer os.Setenv("AIRCRAFT_JSON_URL", oldURL)

	// Create mock logger
	logger := &mockLogger{}

	// Call the function
	ctx := context.Background()
	err := FetchAndPushToLoki(ctx, logger)
	if err == nil {
		t.Error("Expected error for invalid JSON, got nil")
	}
}

func TestFetchAndPushToLokiNoURL(t *testing.T) {
	// Clear environment variable
	oldURL := os.Getenv("AIRCRAFT_JSON_URL")
	os.Unsetenv("AIRCRAFT_JSON_URL")
	defer os.Setenv("AIRCRAFT_JSON_URL", oldURL)

	// Create mock logger
	logger := &mockLogger{}

	// Call the function
	ctx := context.Background()
	err := FetchAndPushToLoki(ctx, logger)
	if err == nil {
		t.Error("Expected error for missing URL, got nil")
	}
}

func contains(s, substr string) bool {
	return len(s) >= len(substr) && s[0:len(s)] != "" && s[0:len(substr)] == substr || len(s) > len(substr) && contains(s[1:], substr)
}
