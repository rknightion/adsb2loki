package flightaware

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"os"
	"testing"

	"github.com/rknightion/adsb2loki/pkg/common"
	"github.com/rknightion/adsb2loki/pkg/models"
)

// mockLogger is a mock implementation of the Logger interface for testing
type mockLogger struct {
	entries []common.LogEntry
	err     error
}

func (m *mockLogger) PushLogs(_ context.Context, entries []common.LogEntry) error {
	m.entries = entries
	return m.err
}

func TestFetchAndPushToLoki(t *testing.T) {
	// Create test data
	testData := models.AutoGenerated{
		Now:      1234567890.123,
		Messages: 100,
		Aircraft: []struct {
			Hex            string        `json:"hex"`
			Flight         string        `json:"flight,omitempty"`
			AltBaro        interface{}   `json:"alt_baro,omitempty"`
			AltGeom        interface{}   `json:"alt_geom,omitempty"`
			Gs             interface{}   `json:"gs,omitempty"`
			Ias            interface{}   `json:"ias,omitempty"`
			Tas            interface{}   `json:"tas,omitempty"`
			Mach           float64       `json:"mach,omitempty"`
			Track          float64       `json:"track,omitempty"`
			TrackRate      float64       `json:"track_rate,omitempty"`
			Roll           float64       `json:"roll,omitempty"`
			MagHeading     float64       `json:"mag_heading,omitempty"`
			BaroRate       interface{}   `json:"baro_rate,omitempty"`
			GeomRate       interface{}   `json:"geom_rate,omitempty"`
			Squawk         string        `json:"squawk,omitempty"`
			Emergency      string        `json:"emergency,omitempty"`
			Category       string        `json:"category,omitempty"`
			NavQnh         float64       `json:"nav_qnh,omitempty"`
			NavAltitudeMcp interface{}   `json:"nav_altitude_mcp,omitempty"`
			NavHeading     float64       `json:"nav_heading,omitempty"`
			Lat            float64       `json:"lat,omitempty"`
			Lon            float64       `json:"lon,omitempty"`
			Nic            int           `json:"nic,omitempty"`
			Rc             int           `json:"rc,omitempty"`
			SeenPos        float64       `json:"seen_pos,omitempty"`
			Version        int           `json:"version,omitempty"`
			NicBaro        int           `json:"nic_baro,omitempty"`
			NacP           int           `json:"nac_p,omitempty"`
			NacV           int           `json:"nac_v,omitempty"`
			Sil            int           `json:"sil,omitempty"`
			SilType        string        `json:"sil_type,omitempty"`
			Gva            int           `json:"gva,omitempty"`
			Sda            int           `json:"sda,omitempty"`
			Mlat           []interface{} `json:"mlat"`
			Tisb           []interface{} `json:"tisb"`
			Messages       int           `json:"messages"`
			Seen           float64       `json:"seen"`
			Rssi           float64       `json:"rssi"`
			NavAltitudeFms interface{}   `json:"nav_altitude_fms,omitempty"`
			NavModes       []string      `json:"nav_modes,omitempty"`
			Type           string        `json:"type,omitempty"`
			R              string        `json:"r,omitempty"`
			T              string        `json:"t,omitempty"`
			Desc           string        `json:"desc,omitempty"`
			Wd             interface{}   `json:"wd,omitempty"`
			Ws             interface{}   `json:"ws,omitempty"`
			Oat            interface{}   `json:"oat,omitempty"`
			Tat            interface{}   `json:"tat,omitempty"`
			TrueHeading    float64       `json:"true_heading,omitempty"`
			Alert          int           `json:"alert,omitempty"`
			Spi            int           `json:"spi,omitempty"`
			RDst           float64       `json:"r_dst,omitempty"`
			RDir           float64       `json:"r_dir,omitempty"`
		}{
			{
				Hex:     "ABC123",
				Flight:  "TEST123",
				AltBaro: 35000,
				Lat:     40.7128,
				Lon:     -74.0060,
			},
			{
				Hex:     "DEF456",
				Flight:  "TEST456",
				AltBaro: 25000,
				Lat:     51.5074,
				Lon:     -0.1278,
			},
		},
	}

	// Create test server
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(testData); err != nil {
			t.Errorf("Failed to encode test data: %v", err)
		}
	}))
	defer server.Close()

	// Set environment variable
	os.Setenv("AIRCRAFT_JSON_URL", server.URL)

	// Create mock logger
	logger := &mockLogger{}

	// Test successful fetch and push
	ctx := context.Background()
	err := FetchAndPushToLoki(ctx, logger)
	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}

	// Verify entries were pushed
	if len(logger.entries) != 2 {
		t.Errorf("Expected 2 entries, got %d", len(logger.entries))
	}

	// Verify entry content
	for i, entry := range logger.entries {
		if entry.Labels["app"] != "flightaware" {
			t.Errorf("Expected app label to be 'flightaware', got %s", entry.Labels["app"])
		}
		if i == 0 && entry.Labels["hex"] != "ABC123" {
			t.Errorf("Expected hex to be 'ABC123', got %s", entry.Labels["hex"])
		}
		if i == 1 && entry.Labels["hex"] != "DEF456" {
			t.Errorf("Expected hex to be 'DEF456', got %s", entry.Labels["hex"])
		}
	}
}

func TestFetchAndPushToLoki_ServerError(t *testing.T) {
	// Create test server that returns an error
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
		w.WriteHeader(http.StatusInternalServerError)
	}))
	defer server.Close()

	// Set environment variable
	os.Setenv("AIRCRAFT_JSON_URL", server.URL)

	// Create mock logger
	logger := &mockLogger{}

	// Test fetch with server error
	ctx := context.Background()
	err := FetchAndPushToLoki(ctx, logger)
	if err == nil {
		t.Error("Expected error for server error, got nil")
	}
}

func TestFetchAndPushToLoki_InvalidJSON(t *testing.T) {
	// Create test server that returns invalid JSON
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		if _, err := w.Write([]byte("invalid json")); err != nil {
			t.Errorf("Failed to write response: %v", err)
		}
	}))
	defer server.Close()

	// Set environment variable
	os.Setenv("AIRCRAFT_JSON_URL", server.URL)

	// Create mock logger
	logger := &mockLogger{}

	// Test fetch with invalid JSON
	ctx := context.Background()
	err := FetchAndPushToLoki(ctx, logger)
	if err == nil {
		t.Error("Expected error for invalid JSON, got nil")
	}
}

func TestFetchAndPushToLoki_ContextCancelled(t *testing.T) {
	// Create test server with delay
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Wait for context to be cancelled
		<-r.Context().Done()
		w.WriteHeader(http.StatusRequestTimeout)
	}))
	defer server.Close()

	// Set environment variable
	os.Setenv("AIRCRAFT_JSON_URL", server.URL)

	// Create mock logger
	logger := &mockLogger{}

	// Create cancelled context
	ctx, cancel := context.WithCancel(context.Background())
	cancel()

	// Test fetch with cancelled context
	err := FetchAndPushToLoki(ctx, logger)
	if err == nil {
		t.Error("Expected error for cancelled context, got nil")
	}
}

// Test with mixed type data (some numeric, some strings)
func TestFetchAndPushToLoki_MixedTypes(t *testing.T) {
	// Create test data with mixed types
	testJSON := `{
		"now": 1234567890.123,
		"messages": 100,
		"aircraft": [
			{
				"hex": "ABC123",
				"flight": "TEST123",
				"alt_baro": 35000,
				"gs": 450.5,
				"lat": 40.7128,
				"lon": -74.0060
			},
			{
				"hex": "DEF456",
				"flight": "GROUND1",
				"alt_baro": "ground",
				"gs": 0,
				"lat": 51.5074,
				"lon": -0.1278
			}
		]
	}`

	// Create test server
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		if _, err := w.Write([]byte(testJSON)); err != nil {
			t.Errorf("Failed to write response: %v", err)
		}
	}))
	defer server.Close()

	// Set environment variable
	os.Setenv("AIRCRAFT_JSON_URL", server.URL)

	// Create mock logger
	logger := &mockLogger{}

	// Test successful fetch and push
	ctx := context.Background()
	err := FetchAndPushToLoki(ctx, logger)
	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}

	// Verify entries were pushed
	if len(logger.entries) != 2 {
		t.Errorf("Expected 2 entries, got %d", len(logger.entries))
	}
}

// Simple contains function for tests
func contains(s, substr string) bool {
	return len(s) >= len(substr) && s[0:len(s)] != "" && s[0:len(substr)] == substr || len(s) > len(substr) && contains(s[1:], substr)
}
