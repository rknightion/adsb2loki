package models

import (
	"encoding/json"
	"testing"
)

func TestAutoGeneratedUnmarshal(t *testing.T) {
	jsonData := `{
		"now": 1234567890,
		"messages": 1000,
		"aircraft": [
			{
				"hex": "ABC123",
				"flight": "TEST123",
				"alt_baro": 35000,
				"gs": 450.5,
				"track": 180.0,
				"lat": 40.7128,
				"lon": -74.0060,
				"squawk": "1234",
				"category": "A3",
				"mlat": [],
				"tisb": [],
				"messages": 50,
				"seen": 0.5,
				"rssi": -10.5
			}
		]
	}`

	var data AutoGenerated
	err := json.Unmarshal([]byte(jsonData), &data)
	if err != nil {
		t.Fatalf("Failed to unmarshal JSON: %v", err)
	}

	// Verify top-level fields
	if data.Now != 1234567890 {
		t.Errorf("Expected Now=1234567890, got %f", data.Now)
	}
	if data.Messages != 1000 {
		t.Errorf("Expected Messages=1000, got %d", data.Messages)
	}

	// Verify aircraft data
	if len(data.Aircraft) != 1 {
		t.Fatalf("Expected 1 aircraft, got %d", len(data.Aircraft))
	}

	aircraft := data.Aircraft[0]
	if aircraft.Hex != "ABC123" {
		t.Errorf("Expected Hex=ABC123, got %s", aircraft.Hex)
	}
	if aircraft.Flight != "TEST123" {
		t.Errorf("Expected Flight=TEST123, got %s", aircraft.Flight)
	}

	// Check interface{} fields
	if altBaro, ok := aircraft.AltBaro.(float64); ok {
		if altBaro != 35000 {
			t.Errorf("Expected AltBaro=35000, got %f", altBaro)
		}
	} else {
		t.Errorf("Expected AltBaro to be float64, got %T", aircraft.AltBaro)
	}

	if gs, ok := aircraft.Gs.(float64); ok {
		if gs != 450.5 {
			t.Errorf("Expected Gs=450.5, got %f", gs)
		}
	} else {
		t.Errorf("Expected Gs to be float64, got %T", aircraft.Gs)
	}

	if aircraft.Track != 180.0 {
		t.Errorf("Expected Track=180.0, got %f", aircraft.Track)
	}
	if aircraft.Lat != 40.7128 {
		t.Errorf("Expected Lat=40.7128, got %f", aircraft.Lat)
	}
	if aircraft.Lon != -74.0060 {
		t.Errorf("Expected Lon=-74.0060, got %f", aircraft.Lon)
	}
}

func TestAutoGeneratedMarshal(t *testing.T) {
	// Test marshaling works by creating data and marshaling it
	jsonData := `{
		"now": 1234567890,
		"messages": 1000,
		"aircraft": [
			{
				"hex": "ABC123",
				"flight": "TEST123",
				"alt_baro": 35000,
				"gs": 450.5,
				"track": 180.0,
				"lat": 40.7128,
				"lon": -74.0060,
				"mlat": [],
				"tisb": []
			}
		]
	}`

	var data AutoGenerated
	err := json.Unmarshal([]byte(jsonData), &data)
	if err != nil {
		t.Fatalf("Failed to unmarshal JSON: %v", err)
	}

	// Marshal it back
	jsonBytes, err := json.Marshal(data)
	if err != nil {
		t.Fatalf("Failed to marshal data: %v", err)
	}

	// Verify the JSON contains expected fields
	jsonStr := string(jsonBytes)
	expectedFields := []string{
		`"now":1234567890`,
		`"messages":1000`,
		`"hex":"ABC123"`,
		`"flight":"TEST123"`,
		`"alt_baro":35000`,
		`"gs":450.5`,
		`"track":180`,
		`"lat":40.7128`,
		`"lon":-74.006`,
	}

	for _, field := range expectedFields {
		if !contains(jsonStr, field) {
			t.Errorf("Expected JSON to contain %s, got %s", field, jsonStr)
		}
	}
}

func TestAutoGeneratedStructure(t *testing.T) {
	// Test with mixed types - unmarshal JSON with different value types
	jsonData := `{
		"now": 1234567890.123,
		"messages": 1000,
		"aircraft": [
			{
				"hex": "ABC123",
				"flight": "TEST123",
				"alt_baro": 35000,
				"alt_geom": 35725,
				"gs": 450.5,
				"ias": 250,
				"tas": 480,
				"lat": 40.7128,
				"lon": -74.0060
			},
			{
				"hex": "DEF456",
				"flight": "TEST456",
				"alt_baro": "ground",
				"alt_geom": "ground",
				"gs": 0,
				"ias": 0,
				"tas": 0,
				"lat": 51.5074,
				"lon": -0.1278
			}
		]
	}`

	var data AutoGenerated
	err := json.Unmarshal([]byte(jsonData), &data)
	if err != nil {
		t.Fatalf("Failed to unmarshal JSON: %v", err)
	}

	// Verify data
	if data.Now != 1234567890.123 {
		t.Errorf("Expected Now to be 1234567890.123, got %f", data.Now)
	}

	if data.Messages != 1000 {
		t.Errorf("Expected Messages to be 1000, got %d", data.Messages)
	}

	if len(data.Aircraft) != 2 {
		t.Errorf("Expected 2 aircraft, got %d", len(data.Aircraft))
	}

	// Test first aircraft with numeric values
	if data.Aircraft[0].Hex != "ABC123" {
		t.Errorf("Expected Hex to be ABC123, got %s", data.Aircraft[0].Hex)
	}

	// Test altitude as number
	if alt, ok := data.Aircraft[0].AltBaro.(float64); ok {
		if alt != 35000 {
			t.Errorf("Expected AltBaro to be 35000, got %f", alt)
		}
	} else {
		t.Errorf("Expected AltBaro to be a float64, got %T", data.Aircraft[0].AltBaro)
	}

	// Test second aircraft with string altitude
	if data.Aircraft[1].Hex != "DEF456" {
		t.Errorf("Expected Hex to be DEF456, got %s", data.Aircraft[1].Hex)
	}

	// Test altitude as string
	if alt, ok := data.Aircraft[1].AltBaro.(string); ok {
		if alt != "ground" {
			t.Errorf("Expected AltBaro to be 'ground', got %s", alt)
		}
	} else {
		t.Errorf("Expected AltBaro to be a string, got %T", data.Aircraft[1].AltBaro)
	}
}

func TestAutoGeneratedWithRealData(t *testing.T) {
	// Test with real-world data sample
	jsonData := `{
		"now":1748083431,
		"messages":342834118,
		"aircraft":[
			{
				"hex":"3c4a8c",
				"type":"adsb_icao",
				"flight":"DLH400  ",
				"r":"D-ABTL",
				"t":"B744",
				"desc":"BOEING 747-400",
				"alt_baro":34000,
				"alt_geom":34725,
				"gs":440.7,
				"ias":297,
				"tas":494,
				"mach":0.848,
				"oat":-50,
				"tat":-18,
				"track":291.85,
				"track_rate":0.22,
				"roll":5.1,
				"mag_heading":294.61,
				"true_heading":293.63,
				"baro_rate":0,
				"geom_rate":32,
				"squawk":"0631",
				"category":"A5",
				"nav_qnh":1013.6,
				"nav_altitude_mcp":34016,
				"nav_heading":300.23,
				"lat":52.525772,
				"lon":-5.353775,
				"nic":8,
				"rc":186,
				"seen_pos":13.639,
				"r_dst":177.252,
				"r_dir":303.4,
				"version":2,
				"nic_baro":1,
				"nac_p":9,
				"nac_v":1,
				"sil":3,
				"sil_type":"perhour",
				"gva":1,
				"sda":2,
				"alert":0,
				"spi":0,
				"mlat":[],
				"tisb":[],
				"messages":30543,
				"seen":7.3,
				"rssi":-34.4
			}
		]
	}`

	var data AutoGenerated
	err := json.Unmarshal([]byte(jsonData), &data)
	if err != nil {
		t.Fatalf("Failed to unmarshal real data: %v", err)
	}

	// Verify parsing worked
	if len(data.Aircraft) != 1 {
		t.Fatalf("Expected 1 aircraft, got %d", len(data.Aircraft))
	}

	aircraft := data.Aircraft[0]
	if aircraft.Hex != "3c4a8c" {
		t.Errorf("Expected Hex=3c4a8c, got %s", aircraft.Hex)
	}
	if aircraft.Type != "adsb_icao" {
		t.Errorf("Expected Type=adsb_icao, got %s", aircraft.Type)
	}
	if aircraft.R != "D-ABTL" {
		t.Errorf("Expected R=D-ABTL, got %s", aircraft.R)
	}
}

// Simple contains function for tests
func contains(s, substr string) bool {
	return len(s) >= len(substr) && s[0:len(s)] != "" && s[0:len(substr)] == substr || len(s) > len(substr) && contains(s[1:], substr)
}
